---
title: "cohort_identification_prone_incidence"
author: "Anna Barker and Chad Hochberg"
date: "`r Sys.Date()`"
output: html_document
---

#Specify File Paths, Project Path and Site - SITE SPECIFIC
#Load the Required CLIF Tables (or if using ARROW/parquet refer to table in situ on storage drive)
```{r}
#Time Zone Options for this Analysis: EST = 'America/New_York', CST = 'America/Chicago', PST = 'America/Los_Angeles'

site_time_zone <- 'America/New_York'
tables_location <- 'Z:/barker/clif_3_22/CLIF-2.0.0-dttm-update-R'
project_location <- 'Z:/barker/clif_3_22/CLIF-2.0.0-dttm-update-R'
site <- "Michigan"
file_type <- "parquet"

check_timezone <- function(site_timezone, intended_timezone = Sys.timezone()) {
  if (site_timezone != intended_timezone) {
    cat("Warning: You specified", site_timezone, "but your system time zone is", intended_timezone, "\n")
    response <- readline(prompt = "Was that intentional? (yes/no): ")
    
    if (tolower(response) %in% c("no", "n")) {
      new_timezone <- readline(prompt = "Please enter the correct timezone: ")
      cat("Timezone updated to", new_timezone, "\n")
      return(new_timezone)
    } else {
      cat("Proceeding with the originally specified timezone:", site_timezone, "\n")
      return(site_timezone)
    }
    
  } else {
    cat("Timezone is set to", site_timezone, "\n")
    return(site_timezone)
  }
}


#Time Zone Check
result <- check_timezone(site_time_zone)

#Create Sub Folders within Project Folder
# Check if the output directory exists; if not, create it
if (!dir.exists(paste0(project_location, "/project_tables"))) {
  dir.create(paste0(project_location, "/project_tables"))
}
if (!dir.exists(paste0(project_location, "/project_output"))) {
  dir.create(paste0(project_location, "/project_output"))
}
```


```{r Load Needed Libraries, include=FALSE}
packages <- c("duckdb", 
              "lubridate", 
              "tidyverse", 
              "dplyr",
              "table1", 
              "broom", 
              "arrow", 
              "rvest", 
              "readr", 
              "fst", 
              "data.table", 
              "collapse", 
              "tictoc")

install_if_missing <- function(package) {
  if (!require(package, character.only = TRUE)) {
    install.packages(package, dependencies = TRUE)
    library(package, character.only = TRUE)
  }
}

sapply(packages, install_if_missing)
rm(packages, install_if_missing)

#Use Dplyr select as default
select <- dplyr::select

```

```{r Keep Track of HOw Long this Markdown Takes to Run, Can Potentially Identify Issues}
tic()
```

#Objective: identify a cohort of hospitalizations with patients who receive mechanical ventilation from CLIF tables
Identify patients admitted to the hospital in a given date range. Export a list of `hospitalization_id` and filtered CLIF tables for the identified hospitalizations.

# Specify inpatient cohort parameters
Age >= 18 Years
PF <=150 on PEEP >= 5 and FiO2 >= 0.6
Criteria are met in the first 36 hours of IMV initiation (t_PROSEVA_first)
AND
Confirmed on second qualifying blood gas in a 12-hour window beginning 12 hours after the first eligible blood gas (t_proseva_first + 12 hours > t_proseva_second < t_proseva_first + 24 hours)
OR
Patient is proned within 24 hours of initial qualifying blood gas (t_PROSEVA_first < t_proning < t_PROSEVA_first + 24 hours)

## Date range
Specify the start and end dates for the cohort
```{r Start Times and Whether Pediatric Patients Are Included}
start_date <- as.POSIXct("2018-01-01", tz=site_time_zone)
end_date <- as.POSIXct("2024-12-31", tz=site_time_zone)

include_pediatric <- FALSE
include_er_deaths <- TRUE
```

#Specify required CLIF Tables
```{r}
#List of table names from CLIF 2.0
tables <- c("patient", "hospitalization", "vitals", "labs", 
            "medication_admin_continuous", "adt", 
            "patient_assessments", "respiratory_support", "position", 
            "dialysis", "intake_output", "ecmo_mcs", "procedures", 
            "admission_diagnosis", "provider", "sensitivity", 
            "medication_orders", "medication_admin_intermittent", 
            "therapy_details", "microbiology_culture", "sensitivity", "microbiology_nonculture")

# Tables that should be set to TRUE for this project
true_tables <- c("patient", "hospitalization", "adt", "patient_assessments",
                 "vitals", "labs", "medication_admin_continuous", "respiratory_support",
                 "position", "microbiology_nonculture")

# Create a named vector and set the boolean values
table_flags <- setNames(tables %in% true_tables, tables)
```



```{r}
# List all CLIF files in the directory
clif_table_filenames <- list.files(path = tables_location, 
                                   pattern = paste0("^clif_.*\\.", file_type, "$"), 
                                   full.names = TRUE)

# Extract the base names of the files (without extension)
clif_table_basenames <- basename(clif_table_filenames) |>
  str_remove(paste0("\\.", file_type, "$"))

# Create a lookup table for required files based on table_flags
required_files <- paste0("clif_", names(table_flags)[table_flags])

# Check if all required files are present
missing_tables <- setdiff(required_files, clif_table_basenames)
if (length(missing_tables) > 0) {
  stop(paste("Error: Missing required tables:", paste(missing_tables, collapse = ", ")))
}

# Filter only the filenames that are required
required_filenames <- clif_table_filenames[clif_table_basenames %in% required_files]

# Read the required files into a list of data frames
if (file_type == "parquet") {
  data_list <- lapply(required_filenames, open_dataset)
} else if (file_type == "csv") {
  data_list <- lapply(required_filenames, read_csv)
} else if (file_type == "fst") {
  data_list <- lapply(required_filenames, read.fst)
} else {
  stop("Unsupported file format")
}

# Assign the data frames to variables based on their file names
for (i in seq_along(required_filenames)) {
  # Extract the base name of the file (without extension)
  object_name <- str_remove(basename(required_filenames[i]), paste0("\\.", file_type, "$"))
  # Make the object name valid for R (replace invalid characters with underscores)
  object_name <- make.names(object_name)
  # Assign the tibble to a variable with the name of the file
  assign(object_name, data_list[[i]])
}
```

#Now Ready to Identify Cohort
#Identify Hospitalizations for Adults >= 18 Who Were Ever in an ED, Ward or ICU
#At This Stage Identify Encounters that Are 'Linked', that is continuous admission within the health system but in different hospitals (or sometimes ED to inpatient in same hospital)
#Script below will create an 'encounter_block' variable toto identify admissions at the patient_id level that are linked
```{r Identify Hospitalizations in Right Time Frame and Age}
clif_hospitalization <- clif_hospitalization |>
   filter(admission_dttm >= start_date &
   admission_dttm <= end_date) |>
   compute()

if (!include_pediatric) {
  clif_hospitalization <- clif_hospitalization |>
    filter(age_at_admission >= 18) |>
    compute()
}

#To be Thorough Will Keep WARD, ICU and ER Encounters (in case of ED to ICU within one system) -> changed to new location_categories
inpatient_hospitalization_ids <- clif_adt |>
  filter(tolower(location_category) %in% c("ward", "icu", "ed", "stepdown")) |>
  select(hospitalization_id) |>
  collect()

clif_hospitalization <- clif_hospitalization |>
  collect() |> #Have to Bring in to Environment To Correctly Filter IDs (at JHH)
  filter(hospitalization_id %in% inpatient_hospitalization_ids$hospitalization_id) |>
  as_arrow_table() #Put Back to Arrow Table
rm(inpatient_hospitalization_ids)

#Create an Hospital Block ID - This is to Identify Continuous Hospitalizations When Patients Are Transferred Between Hospitals in One Health System
#This code is intended be robust to various ways encounters may be coded in CLIF databases
hospital_blocks <- clif_hospitalization |>
  select(patient_id, hospitalization_id, admission_dttm, discharge_dttm) |>
  arrange(patient_id, admission_dttm) |>
  collect()

#Identify Admissions That Occur Within 3 Hours of a Discharge (Will Consider Those Linked and as Part of One Continuous Encounter)
#Use Data Table for Speed
linked_encounters <- setDT(hospital_blocks)
#Create a Variable for the time of the next admission and time of previous discharge
linked_encounters[, ':=' (next_admit_dttm = data.table::shift(admission_dttm, n=1, type = "lead")), by = patient_id]
linked_encounters[, ':=' (prev_dc_dttm = data.table::shift(discharge_dttm, n=1, type = "lag")), by = patient_id]
#Calculates Time Between Discharge and Next Admit
linked_encounters[, next_diff_time := difftime(next_admit_dttm, discharge_dttm, units = "hours")]
linked_encounters[, prev_diff_time := difftime(admission_dttm, prev_dc_dttm, units = "hours")]

#Now Create Variable Indicating a Linked Encounter (next_admit-dc time <6 hours or prev_dc-admint <6 hours)
linked_encounters[, linked := fcase(
  (next_diff_time <6 | prev_diff_time <6), 1)]
#Filter to Only Linked Encounters and number them
linked_encounters <- linked_encounters[linked==1]
#This Identifies the First Encounter in a Series of Linked Encounters
linked_encounters[, first_link := fcase(
  (rowid(linked)==1 | (next_diff_time<6 & prev_diff_time>6)), 1
), by = patient_id]
#Now Numbers Encounters, easier in dplyr
#Filter to Just First Links, Number them and then Remerge with linked encounters
temp <- as_tibble(linked_encounters) |>
 filter(first_link==1) |>
 group_by(patient_id) |>
 mutate(link_group=row_number()) |>
 ungroup() |>
 select(hospitalization_id, link_group) 
linked_encounters <- as_tibble(left_join(linked_encounters, temp, join_by(hospitalization_id))) |>
  fill(link_group, .direction = c("down")) |>
  #Create a Variable Indicating Which Number of LIinked Encounter the Encounter is
  group_by(patient_id, link_group) |>
  mutate(link_number=row_number()) |>
  ungroup() |>
  select(hospitalization_id, linked, link_number)
rm(temp)

#Now Join Back to Hospitalization Table
clif_hospitalization <- clif_hospitalization |>
  left_join(linked_encounters) |>
  mutate(linked=if_else(is.na(linked), 0, linked)) |>
  compute()

#Pull Out the Any Linked Encounter that Is NOt the First Encounter and Assign Each Encounter an Encounter Block ID in the Original clif_hospitalization table
df_link <- clif_hospitalization |>
  filter(link_number>1) |>
  collect()

clif_hospitalization <- clif_hospitalization |>
  group_by(patient_id) |>
  arrange(patient_id, admission_dttm) |>
  #Remove Link Numbers that Are Not First in Link Encounter
  filter(link_number==1 | is.na(link_number)) |>
  #Make Encounter Blocks
  collect() |>
  mutate(encounter_block=row_number()) |>
  rowbind(df_link, fill = TRUE) |> #Bring Back in Link Numbers >1
  group_by(patient_id) |> arrange(patient_id, admission_dttm) |>
  fill(encounter_block, .direction = "down") |>
  ungroup()|>
  #Finally, for Linked Encounters Identify 'Final_admit_date' and 'final_dc_date' which are the first and last dates of a link block
  #Finally, for Linked Encounters Identify 'Final_admit_date' and 'final_dc_date' which are the first and last dates of a link block
  group_by(patient_id, encounter_block) |>
  mutate(final_admission_dttm=fcase(
    row_number()==1, as.POSIXct(admission_dttm)
  )) |>
  mutate(final_discharge_dttm=fcase(
    row_number()==n(), as.POSIXct(discharge_dttm)
  )) |>
  mutate(final_discharge_category=fcase(
    row_number()==n(), discharge_category
  )) |>
  mutate(final_discharge_name=fcase(
    row_number()==n(), discharge_name
  )) |>
  fill(final_admission_dttm, 
       final_discharge_dttm,
       final_discharge_name, 
       final_discharge_category, 
       .direction = 'updown') |>
  relocate(encounter_block, .after = 'hospitalization_id') |>
  as_arrow_table()

rm(linked_encounters, df_link, hospital_blocks)

#Keep Track for Consort Diagram
patients <- length(unique(clif_hospitalization$patient_id))
encounters <- length(clif_hospitalization$hospitalization_id)
cat('\n In', site, 'CLIF data there are', patients,'unique patients with', encounters, 'encounters \n')
```

#Filter Only to Patients Who Receive Mechanical Ventilation
```{r}
#Bring in Temporary File with patient_id, hospitalization_id and encounter_block
temp_ids <- clif_hospitalization |>
  select(patient_id, hospitalization_id, encounter_block) |>
  collect()

#Identify Patients Who EVER Received Mechanical Ventilation During a Hospitalization
vent <- clif_respiratory_support |>
  #Only Need IDs in the Current Working ClIF hospitalization Table
  filter(hospitalization_id %in% temp_ids$hospitalization_id) |>
  #Will Also Merge in Encounter Block Here - Will Allow Us to Keep Track of LInked Encounters
  left_join(temp_ids) |>
  compute()
rm(temp_ids)

#Identify Those Who Have Ever Been on a Vent During an Encounter Block
vent <- vent |> 
  mutate(on_vent=if_else(device_category=='IMV', 1, 0)) |>
  group_by(patient_id, encounter_block) |>
  mutate(ever_vent=if_else(max(on_vent, na.rm=T)==1, 1, 0)) |>
  filter(ever_vent==1) |>
  select(-ever_vent) |>
  ungroup() |>
  compute()

#Identify First Vent Start Time and Vent Duration
#Keep Track for Consort Diagram
patients <- length(unique(vent$patient_id))
encounters <- length(unique(vent$hospitalization_id))
cat('\n Paitents Receiving Mechanical Ventilation: \n  In', site, 'CLIF data there are', patients,'unique patients with', encounters, 'encounters \n')
```

#Identify Ventilator Episodes
```{r}
#Now Identify Ventilator Episodes and the Duration of Each Episodes
#This Uses Logic Created by Nick Ingraham to Carry Forward Device Category and Device Names
vent <- vent |>
  mutate(
    device_category = 
    if_else(
        is.na(device_category) & is.na(device_name) &
          str_detect(mode_category, 
                     "Pressure Control|Assist Control-Volume Control|Pressure Support/CPAP|Pressure-Regulated Volume Control|SIMV"),
        "IMV",
        device_category
      ),
    device_name = 
      if_else(
        str_detect(device_category, "IMV") & is.na(device_name) &
          str_detect(mode_category, "Pressure Control|Assist Control-Volume Control|Pressure Support/CPAP|Pressure-Regulated Volume Control|SIMV"),
        "IMV",
        device_name
      ),
  ) |>
  collect() |>
  #     If device before is VENT + normal vent things ... its VENT too 
  group_by(patient_id, encounter_block) |>
  arrange(patient_id, recorded_dttm) |>
  mutate(device_category = fifelse(is.na(device_category) & 
                                     lag(device_category == "IMV") & 
                                     tidal_volume_set > 1 & 
                                     resp_rate_set > 1 & 
                                     peep_set > 1, 
                                   "IMV", 
                                   device_category)) |>
  # If device after is VENT + normal vent things ... its VENT too 
  mutate(device_category = fifelse(is.na(device_category) & 
                                     lead(device_category == "IMV") & 
                                     tidal_volume_set > 1 & 
                                     resp_rate_set > 1 & 
                                     peep_set > 1, 
                                   "IMV", 
                                   device_category)) |>
  # doing this for BiPAP as well
  mutate(device_category = fifelse(is.na(device_category) & 
                                     lag(device_category == "NIPPV") & 
                                     #minute_vent > 1 & ###NEED TO BUILD INTO JHU DATA
                                     pressure_support_set > 1, 
                                   "NIPPV", 
                                   device_category)) |>
  
  mutate(device_category = fifelse(is.na(device_category) & 
                                     lead(device_category == "NIPPV") & 
                                     #minute_vent > 1 & ###NEED TO BUILD INTO JHU DATA
                                     pressure_support_set > 1, 
                                   "NIPPV", 
                                   device_category)) |>
  ungroup()
  
# Now use a Fill Forward Method with Device Category
vent <- vent |>
  group_by(patient_id, encounter_block) |>
  fill(device_category, .direction = 'downup') |>
  ungroup() |>
  as_arrow_table()

#Goal of Function Below is to Define Ventilator Episodes & Ventilator Liberations (> 24 Hours off of MV)
#First will Filter Down to Reduced Table of 'device_category' transitions; For example: This includes rows when a device_category switches from one to another; Also keep First and Last Rows
device_transitions <- vent |> 
  arrange(patient_id, recorded_dttm) |> #Puts in Correct Order
  collect() |>
  group_by(patient_id, encounter_block) |>
  mutate(prev_value_diff = fifelse(
    (device_category!=data.table::shift(device_category, n=1, type = "lag")), 1, 0)) |>
  mutate(prev_value_diff=fifelse(is.na(prev_value_diff), 0, prev_value_diff)) |> #For First Row
  filter(prev_value_diff == 1 |
           row_number()==1 | row_number() == n()) |>
  ungroup()

#Define Ventilator Episodes - Define Ventilator Liberation as 24 Hours Breathing Off Ventilator, Otherwise Will Include That Time in Ventilator Duration
#For Patients Who Start IMV on Last Row can Calculate Time on Vent Using Final Discharge Time
dc_time <- clif_hospitalization |>
  select(patient_id, encounter_block, final_discharge_dttm) |>
  distinct()  |> #1 Row for 1 Encounter Block 
  collect()

#Temporarily Number Vent Episodes
device_transitions <- device_transitions |>
  join(dc_time, how = 'left') |>
  group_by(patient_id, encounter_block, device_category) |>
  mutate(category_number=row_number()) |>
  #If a Last Row of an Enconter Block is Not a Device Transition Set Category Number to NA
  group_by(patient_id, encounter_block) |>
  mutate(category_number=fifelse(
    row_number()==n() & prev_value_diff!=1, NaN, category_number
  )) |>
  ungroup() |>
  group_by(patient_id, encounter_block) |>
#Define Vent Start and Stop (Temporary)
  mutate(vent_start=fcase(
    device_category=='IMV' & (prev_value_diff==1 | row_number()==1), recorded_dttm
  )) |>
  mutate(vent_stop=fcase(
    device_category=='IMV' & lead(prev_value_diff)==1, lead(recorded_dttm),
    device_category=='IMV' & lead(row_number())==n(), lead(recorded_dttm), #This is Why we Kept Last Row
    #If the Last Row is 'IMV' Than Use Discharge Time 
    row_number()==n() & device_category=='IMV', final_discharge_dttm
  )) |>
  fill(vent_stop, .direction = 'down') |>
  #Define Vent Liberation of Prior Vent Episodes as 24 Hours without device_category=='IMV', can fill backwards for this
  mutate(prior_liberation_new_vent=fcase(
    #This says if the next time someone is on a vent > 24 hours after the last time on a vent it will be a new episode
    device_category=='IMV' & category_number==1, 1, #Need to Define This First
    device_category=='IMV' & recorded_dttm>as.POSIXct(lag(vent_stop))+dhours(24), 1,
    device_category=='IMV' & recorded_dttm<=as.POSIXct(lag(vent_stop))+dhours(24), 0
  )) |>
  #Label if Last Row so Vent Duration Can be Defined by Discharge Time
  mutate(last_row=fifelse(row_number()==n(), 1, 0)) |>
  ungroup()

device_transitions <- device_transitions |>
  #Alternative Way of Labelling Liberation
  group_by(patient_id, encounter_block) |>
  mutate(vent_stop=fifelse(
    device_category=='IMV' & is.na(vent_stop) & last_row==1, final_discharge_dttm, as.POSIXct(vent_stop))) |>
  mutate(liberation=fcase(
    device_category!='IMV' & recorded_dttm>as.POSIXct(vent_stop)+dhours(24), 1,
    device_category=='IMV' & last_row==1, 0
  )) |>
  fill(liberation, .direction = 'up') |>
  ungroup()
rm(dc_time)

#Renumber 'New' Episodes of MV, that is if the first episode, and then episodes in which the patient was previously liberated, keep the intervening episodes so we can count final duration
vent_episodes <- device_transitions |>
  filter(device_category=='IMV') |>
  group_by(patient_id, encounter_block, prior_liberation_new_vent) |>
  mutate(vent_episode_number=fifelse(
    prior_liberation_new_vent==1, row_number(), NaN)) |>
  group_by(patient_id, encounter_block) |>
  fill(vent_episode_number, .direction = 'down') |>
  group_by(patient_id, encounter_block, vent_episode_number) |>
  mutate(vent_episode_start=fcase(
    row_number()==1, as.POSIXct(vent_start)
  )) |>
  mutate(vent_episode_end=fcase(
    row_number()==n(), as.POSIXct(vent_stop)
  )) |>
  mutate(liberation=fcase(
    row_number()==n(), liberation,
    default = NaN
  )) |>
  fill(vent_episode_start, vent_episode_end, liberation, mode_category, .direction = 'downup') |>
  #Now Keep First Row for Each Vent Episode
  filter(row_number()==1) |>
  ungroup() |>
  #Calculate Vent Duration
  mutate(vent_duration_hours=as.duration(vent_episode_end-vent_episode_start)/dhours(1)) |>
  select(patient_id, hospitalization_id, encounter_block, device_category, mode_category, 
         liberation, vent_duration_hours, vent_episode_number, vent_episode_end, vent_episode_start)

#Describe Numbers
cat('\nAt this stage in', site, 'data there are', dim(vent_episodes)[1], 'ventilator episodes among', 
    length(unique(vent_episodes$hospitalization_id)), 'hospitalizations from', 
    length(unique(vent_episodes$patient_id)), 'patients.')

#Now Filter to Just First Vent Episodes that are Greater than 36 Hours Long
vent_eligible <- vent_episodes |>
  group_by(patient_id, encounter_block) |>
  filter(vent_episode_number==1 & vent_duration_hours>36) |>
  ungroup()

#Describe Numbers
cat(site, '\n After filtering to patients with >36 hours of MV for First Episode there are,', dim(vent_eligible)[1], 'ventilator episodes among,',length(unique(vent_eligible$hospitalization_id)), 'hospitalizations from',length(unique(vent_eligible$patient_id)), 'patients.')

rm(device_transitions)
```
#EXLUSIONS:
-Tracheostomy prior to completing first 24 hours of first vent (includes tracheostomy on admission). 
-Patient admitted from OSH on the vent
-After Final Identiication of ABG criteria will then randomly select 1 eligible encounter for each patient with more than 1 eligible
```{r Implement Exclusion Criteria}
#List of patient_id, encounter_block, hospitalization_id and vent_start
temp_ids <- vent_eligible |>
  select(patient_id, encounter_block) |>
  mutate(in_cohort=1)
#Create a Table Containing the 3 Identifiers c('patient_id', 'hospitalization_id', 'encounter_block')
cohort_ids <- clif_hospitalization |>
  left_join(temp_ids) |>
  filter(in_cohort==1) |>
  select(patient_id, hospitalization_id, encounter_block, in_cohort) |>
  collect()
rm(temp_ids)

#Tracheostomy in First 24 Hours of First Vent 
trach <- clif_respiratory_support |>
  left_join(cohort_ids) |>
  filter(in_cohort==1) |> #This allows us to keep all encounter block info
  select(patient_id, recorded_dttm, encounter_block, tracheostomy) |>
  filter(tracheostomy==1) |>
  arrange(patient_id, encounter_block, recorded_dttm) |>
  collect() |>
  group_by(patient_id, encounter_block) |>
  filter(row_number()==1) |>
  mutate(first_trach_time=fcase(
    row_number()==1, as.POSIXct(recorded_dttm)
  )) |>
  ungroup() |>
  select(patient_id, encounter_block, tracheostomy, first_trach_time)

#Merge with Vent Eligible and Exclude if first_trach_time within 24 hours of vent start
vent_eligible <- vent_eligible |>
  join(trach, how = 'left') |>
  mutate(tracheostomy=fifelse(is.na(tracheostomy), 0, tracheostomy)) |> #If not merged indicates no trach performed
  mutate(trach_within_24=fcase(
    as.POSIXct(vent_episode_start)+dhours(24)>first_trach_time, 1,
    default = 0
  ))

#Describe for Consort
cat('\n At', site,',', length(unique(vent_eligible$hospitalization_id[vent_eligible$tracheostomy==1])), 'patient hospitalizations were ventilated via a tracheostomy,', length(unique(vent_eligible$hospitalization_id[vent_eligible$trach_within_24==1])), 'within 24 hours of ventilator start and are thus excluded. \n')

#Vent Eligible Excluding Early Trach
vent_eligible <- vent_eligible |>
  filter(trach_within_24!=1)
#rm(trach)
#Update Cohort_IDs
#List of patient_id, encounter_block, hospitalization_id and vent_start
temp_ids <- vent_eligible |>
  select(patient_id, encounter_block) |>
  mutate(in_cohort=1)
#Create a Table Containing the 3 Identifiers c('patient_id', 'hospitalization_id', 'encounter_block')
cohort_ids <- clif_hospitalization |>
  left_join(temp_ids) |>
  filter(in_cohort==1) |>
  select(patient_id, hospitalization_id, encounter_block, in_cohort) |>
  collect()
rm(temp_ids)

#How Many Patients Arrive First to ICU and First Device is a Vent?
#First Define What the First Location Is
osh_transfer <- clif_adt |>
  left_join(cohort_ids) |> #Here need to join first and then filter to those in cohort
  filter(in_cohort==1) |>
  arrange(patient_id, encounter_block, in_dttm) |>
  collect() |>
  group_by(patient_id, encounter_block) |> # Replace group_column with the column(s) you want to group by
  filter(row_number()==1) |>
  ungroup() |>
  mutate(first_location=location_category)

#Now Define First Device Category
first_device <- clif_respiratory_support |>
  left_join(cohort_ids) |> #Here need to join first and then filter to those in cohort
  filter(in_cohort==1) |>
  filter(!is.na(device_category)) |>
  arrange(patient_id, encounter_block, recorded_dttm) |>
  collect() |>
  group_by(patient_id, encounter_block) |>
  filter(row_number()==1) |>
  mutate(first_device=device_category) |>
  select(patient_id, encounter_block, first_device)

#Merge back with OSH
osh_transfer <- osh_transfer |>
  join(first_device, how ='left') |>
  mutate(transfer_on_vent=fifelse(
    tolower(first_location)=='icu' & first_device=='IMV', 1, 0
  )) |>
  select(patient_id, encounter_block, transfer_on_vent)

#Merge Into Vent Eligible
vent_eligible <- vent_eligible |>
  left_join(osh_transfer, join_by(patient_id, encounter_block)) 
rm(osh_transfer, first_device)

#Describe for Consort
cat('\n At', site,',', length(unique(vent_eligible$hospitalization_id[vent_eligible$transfer_on_vent==1])), 'patient hospitalizations were from patients who met criteria for having been transfered while on a ventilator and are thus excluded,') 

#Current Vent Eligible Cohort
vent_eligible <- vent_eligible |>
  filter(transfer_on_vent!=1)
cat('this yields an eligible ventilator cohort of,', length(unique(vent_eligible$hospitalization_id)), 'hospitalizations, among',
              length(unique(vent_eligible$patient_id)), 'patients. \n')     

#Update Running Table of Cohort IDs
#List of patient_id, encounter_block, hospitalization_id and vent_start
temp_ids <- vent_eligible |>
  select(patient_id, encounter_block) |>
  mutate(in_cohort=1)
#Create a Table Containing the 3 Identifiers c('patient_id', 'hospitalization_id', 'encounter_block')
cohort_ids <- clif_hospitalization |>
  left_join(temp_ids) |>
  filter(in_cohort==1) |>
  select(patient_id, hospitalization_id, encounter_block, in_cohort) |>
  collect()
rm(temp_ids)
```

```{r Clean CLIF Labs Data for PaO2 and Merge with Respiratory Support for P/F Ratios}
#Will Use cohort_ids table and vent start to filter to relevant hospitalizations and times
vent_times <- vent_eligible |>
  select(patient_id, encounter_block, vent_episode_end, vent_episode_start,first_trach_time, vent_duration_hours, liberation)

#Filter Labs Table to Just Hospitaliztion IDs in the Cohort
clif_labs <- clif_labs |>
  left_join(cohort_ids) |> #NOTE: clif_labs will now include patient_id and encounter_block
  filter(in_cohort==1) |>
  select(-in_cohort) |>
  compute()

#PaO2 Table
pao2 <- clif_labs |>
  filter(lab_category=='po2_arterial' & !is.na(lab_value)) |>
  filter(lab_value!='NULL') |>
  filter(lab_value_numeric>40 & lab_value_numeric<=700) |> #Lower Bound Filtering for PaO2 Outliers > 40 and upper bound assumes FiO2 of 1.0 A-a gradient of 0 and Paco2 of 10
  distinct() |>
  select(patient_id, encounter_block, lab_collect_dttm, lab_value_numeric) |>
  collect() |>
  mutate(recorded_dttm=as.POSIXct(lab_collect_dttm, tz="UTC")) |> #For Merging with Vent Data
  rename(pao2 = lab_value_numeric) 

# Check fio2_set 
fio2_mean <- clif_respiratory_support |> select(fio2_set) |> summarise(fio2_mean = mean(fio2_set, na.rm = TRUE)) |> collect() # fixing if its less than one # You will get a warning but it will be fixed on its own with IF statement 
if(fio2_mean > 1){ 
  clif_respiratory_support <- clif_respiratory_support |> mutate(fio2_set = fio2_set / 100) |> compute() }

#Create Vent Data Table for the First Ventilator Episode (the ONe being analyzed for this study)
#Merge in PaO2 Data Here
vent_data <- clif_respiratory_support |>
  left_join(cohort_ids) |>
  filter(in_cohort==1) |>
  left_join(vent_times) |>
  collect() |>
  mutate(recorded_dttm=as.POSIXct(recorded_dttm, tz = 'UTC')) |>
  filter(recorded_dttm>=as.POSIXct(vent_episode_start, tz="UTC") & recorded_dttm<=as.POSIXct(vent_episode_end, tz="UTC")) |>
  arrange(patient_id, encounter_block, recorded_dttm) |>  
  group_by(patient_id, encounter_block) |>
  fill(device_category, device_name, .direction = 'down') |>
  mutate(recorded_dttm=as.POSIXct(recorded_dttm, tz= 'UTC')) |> #to merge with pao2 data
  ungroup() |>
  #Bring in PaO2 Here and Then Fill Again
  join(pao2, how ='full') |>
  group_by(patient_id, encounter_block) |>
  fill(vent_episode_end, vent_episode_start, .direction = 'downup') |>
  filter(recorded_dttm>=as.POSIXct(vent_episode_start, tz="UTC") & recorded_dttm<=as.POSIXct(vent_episode_end, tz="UTC")) |>
  arrange(patient_id, encounter_block, recorded_dttm) |>  
  fill(device_category, device_name, .direction = 'down') |>
  #Now Group by Patient/Encounter/device_category and fill peep and fio2
  group_by(patient_id, encounter_block, device_category) |>
  mutate(ever_tracheostomy=tracheostomy) |>
  fill(peep_set, 
       fio2_set, 
       vent_episode_start,
       vent_episode_end,
       mode_category,
       first_trach_time,
       liberation,
       vent_duration_hours,
       hospitalization_id,
       ever_tracheostomy,
       .direction = 'downup') |>
  fill(tracheostomy, .direction= 'down') |>
    ungroup() 

#Quality Check FiO2 and PEEP Data
#Calculate PF
#Indicate if 'proseva_eligible'
vent_data <- vent_data |>
  mutate(fio2_set=fifelse(
  fio2_set<0.21 | fio2_set>1, NaN, fio2_set)) |>
#     fio2_set<21 | fio2_set>100, NaN, fio2_set/100)) |>
  mutate(peep_set=fifelse(
    peep_set<0 | peep_set>35, NaN, peep_set)) |>
  #Now Calculate PF Ratios
  mutate(pf_ratio=pao2/fio2_set) |>
  #Indicate if PROSEVA Eligible - This Should ALL be During Vent Episode
  mutate(proseva_eligible=fcase(
    is.na(pao2) | is.na(fio2_set) | is.na(peep_set), NaN,
    pf_ratio<150 & peep_set>=5 & fio2_set>=0.6, 1,
    !is.na(pf_ratio) & (pf_ratio>=150 | peep_set<5 | fio2_set<0.6), 0
  )) 

#Keep Track of How Many ABGs During Eligible Vent Episode and How Many PROSEVA Eligible
pf_table <- vent_data |>
  filter(!is.na(pf_ratio)) |>
  mutate(n_pfs = n()) |>
  group_by(proseva_eligible) |>
  mutate(n_proseva_eligible=n()) |>
  ungroup() |>
  mutate(n_proseva_eligible=fifelse(
    proseva_eligible==1, n_proseva_eligible, NaN)) |>
  fill(n_proseva_eligible, .direction = 'updown') |>
  summarise(
    '# PF Ratios' = mean(n_pfs),
    '# PROSEVA Eligible' = mean(n_proseva_eligible),
    '% PROSEVA Eligible' = round(mean(n_proseva_eligible/n_pfs)*100, digits= 2)
  )
pf_table
write_csv(pf_table, paste0(project_location, "/project_output/",site, "_pfratio_sample_size.csv"))
rm(pf_table, pao2)
```


```{r Implement PROSEVA Inclusion Criteria}
proseva_criteria <- vent_data |>
  filter(!is.na(pf_ratio)) |>
  #Filter to First 72 Hours After Vent Start
  filter(recorded_dttm<=as.POSIXct(vent_episode_start, tz="UTC")+dhours(72)) |>
  mutate(temp_proseva_time=fifelse(
    proseva_eligible==1 & recorded_dttm<=as.POSIXct(vent_episode_start, tz="UTC")+dhours(36), 1, 0
  )) |>
  group_by(patient_id, encounter_block, temp_proseva_time, proseva_eligible) |> #By grouping together can define the 1st PF ratios that Meet PROSEVA criteria
  arrange(patient_id, encounter_block, recorded_dttm) |>
  mutate(temp_pf=row_number()) |>
  ungroup() |>
  #Identify the PF ratio, FIo2, PEEP, and Mode Where Proseva Criteria First met
  mutate(first_proseva_pf=fcase(
    temp_pf==1 & proseva_eligible==1 & temp_proseva_time==1, pf_ratio
  )) |>
  mutate(first_proseva_fio2=fcase(
    temp_pf==1 & proseva_eligible==1 & temp_proseva_time==1, fio2_set
  )) |>
  mutate(first_proseva_peep=fcase(
    temp_pf==1 & proseva_eligible==1 & temp_proseva_time==1, peep_set
  )) |>
  mutate(first_proseva_mode=fcase(
    temp_pf==1 & proseva_eligible==1 & temp_proseva_time==1, mode_category
  )) |>
  mutate(t_proseva_first=fcase(
    temp_pf==1 & proseva_eligible==1 & temp_proseva_time==1, recorded_dttm
  )) |>
  group_by(patient_id, encounter_block) |>
  fill(first_proseva_pf,
       first_proseva_fio2,
       first_proseva_peep,
       first_proseva_mode,
       t_proseva_first,
       .direction = 'updown') |>
  ungroup() |>
  #Now Repeat For The 2nd Eligible Time - Must be within 12-24 Hours t_proseva_first
  #This Table is Already Windowed to First 72 Hours of Vent and Ends When patient is extubated/dies/transfers (if before 72 hours)
  mutate(eligible_proseva_t2=fifelse(
    recorded_dttm>=as.POSIXct(t_proseva_first, tz="UTC")+dhours(12) & 
    recorded_dttm<=as.POSIXct(t_proseva_first, tz="UTC")+dhours(24), 1, 0 # since this is set as 0 when not true, fill updown doesn't overwrite it. 
  )) |>
  group_by(patient_id, encounter_block, eligible_proseva_t2, proseva_eligible) |>
  arrange(patient_id, encounter_block, recorded_dttm) |>
  mutate(temp_pf=row_number()) |>
  ungroup() |>
  mutate(second_proseva_pf=fcase(
    temp_pf==1 & proseva_eligible==1 & eligible_proseva_t2, pf_ratio
  )) |>
  mutate(second_proseva_fio2=fcase(
    temp_pf==1 & proseva_eligible==1 & eligible_proseva_t2, fio2_set
  )) |>
  mutate(second_proseva_peep=fcase(
    temp_pf==1 & proseva_eligible==1 & eligible_proseva_t2, peep_set
  )) |>
  mutate(second_proseva_mode=fcase(
    temp_pf==1 & proseva_eligible==1 & eligible_proseva_t2, mode_category
  )) |>
  mutate(t_proseva_second=fcase(
    temp_pf==1 & proseva_eligible==1 & eligible_proseva_t2, recorded_dttm
  )) |>
  group_by(patient_id, encounter_block) |>
  fill(second_proseva_pf,
       second_proseva_fio2,
       second_proseva_peep,
       second_proseva_mode,
       t_proseva_second,
       .direction = 'updown') |>
  ungroup() |>
  #NOW Define Who is Eligible by PROSEVA criteria
  mutate(eligible_by_proseva=fifelse(
    !is.na(first_proseva_pf) & !is.na(second_proseva_pf), 1, 0
  )) |>
  #Select Wanted Variables and Keep First Row for Each Patient and Encounter Block
  select(patient_id, encounter_block, first_proseva_pf:eligible_by_proseva, ever_tracheostomy) |>
  group_by(patient_id, encounter_block) |>
  filter(row_number()==1) |> #by selecting first row number, proseva_second_eligible ==0  if not missing, fine bc won't use it anymore
  ungroup()

```


```{r Define Potentially Eligible Proning Episodes - Those Occurring During First Ventilator Episode}
#Filter Position Table to Relevant Cohort and Only Times During the First Ventilator Episode
temp_times <- vent_times |> 
  select(patient_id, encounter_block, vent_episode_start, vent_episode_end)

prone_episodes_all <- clif_position |>
  left_join(cohort_ids) |> #NOTE: clif_labs will now include patient_id and encounter_block
  filter(in_cohort==1) |>
  filter(!is.na(position_category)) |>
  select(-in_cohort) |>
  left_join(temp_times) |>
  collect()

#output position data for categories >= 10 times while prone
position_output<- data.frame(table(prone_episodes_all$position_category, prone_episodes_all$position_name, useNA = "always"))
position_output<- position_output %>% filter(Freq>10) # if happening less than 10 times, don't output
position_output<- position_output %>% rename(position_category=Var1) 
position_output<- position_output %>% rename(position_name=Var2)
position_output<- position_output %>% filter(position_category=="prone") 
position_output$semi_prone<- grepl("semi", position_output$position_name, ignore.case = TRUE)  
if(any(position_output$semi_prone==TRUE)) warning("QC: You may have semi-prone data mapped to the proned position_category. Patients in a semi-proned position should not be considered prone unless there is an additional prone documentation at the same time. Please review your position-name to position_category mapping to determine how semi-prone data is mapped to position_category") 
write_csv(position_output, paste0(project_location, "/project_output/",site, "_position_output.csv")) 
  
prone_episodes <- prone_episodes_all |>
  mutate(recorded_dttm=as.POSIXct(recorded_dttm, tz="UTC")) |>
  filter(recorded_dttm>=as.POSIXct(vent_episode_start, tz="UTC") & recorded_dttm<=as.POSIXct(vent_episode_end, tz="UTC")) |>
  #Filter to Rows Where 'position_category' changes --> This will allow some institutions to select 'all positions' and some to only keep rows where position changes (as I did in my CLIF ETL)
  group_by(patient_id, encounter_block) |>
  arrange(patient_id, encounter_block, recorded_dttm) |>
  mutate(keep=fcase(
    row_number()==1, 1,
    row_number()==n(), 1,
    position_category!=lag(position_category), 1)) |>
  mutate(keep=fifelse(
    #IF Both Prone and Supine Are Recorded at the Same Time Will Exclude
    position_category!=lag(position_category) & recorded_dttm==lag(recorded_dttm), 0, keep)) |>
  ungroup() |>
  filter(keep==1) |>
  #Deal with Last Row if It is NOT a new Category
  group_by(patient_id, encounter_block) |>
  mutate(keep=fifelse(
    row_number()==n() & 
      position_category==lag(position_category) &
      n()>1, 0, keep
  )) |>
  #Calculate the Time in Hours to Next Observation - For the Second to Last Row
  mutate(time_to_lastrow=fcase(
    lead(keep)==0,
    as.duration(lead(recorded_dttm)-recorded_dttm)/dhours(1))) |>
  #This Keeps Track of Whether the Last Observation in a Position_category SHould Use the Vent-end or time to last row to determine duration
  mutate(use_time_to_lastrow=fcase(
    lead(row_number())==n() & lead(keep)==0, 1,
    row_number()==n() & keep==1, 0,
    default = 0
  )) |>
  filter(keep==1) |>
  #Now Define # of Prone Episodes (during First Ventilator Episode)
  group_by(patient_id, encounter_block, position_category) |>
  mutate(temp_episode_num=row_number()) |>
  ungroup() |>
  group_by(patient_id, encounter_block) |>
  mutate(prone_episode_num=fcase(
    position_category=='prone', temp_episode_num)) |>
  ungroup() |>
  #Define Prone Position Duration - Time to Next Row OR if the Prone Episode is Last Row it is Time to Vent End
  group_by(patient_id, encounter_block) |>
  arrange(patient_id, encounter_block, recorded_dttm) |>
  mutate(prone_episode_hours=fcase(
    position_category=='prone' & row_number()!=n(), as.duration(lead(recorded_dttm)-recorded_dttm)/dhours(1),
    position_category=='prone' & row_number()==n() & use_time_to_lastrow==0, as.duration(vent_episode_end-recorded_dttm)/dhours(1),
    position_category=='prone' & row_number()==n() & use_time_to_lastrow==1, time_to_lastrow,
    position_category=='prone' & row_number()==1 & use_time_to_lastrow==0, as.duration(vent_episode_end-recorded_dttm)/dhours(1),
    position_category=='prone' & row_number()==1 & use_time_to_lastrow==1, time_to_lastrow
  )) |>
  filter(position_category=='prone') |>
  mutate(prone_episodes=max(prone_episode_num)) |>
  mutate(first_prone_episode_hours=fcase(
    prone_episode_num==1, prone_episode_hours
  )) |>
  mutate(first_prone_time=fcase(
    prone_episode_num==1, as.POSIXct(recorded_dttm, tz="UTC")
  )) |>
  mutate(median_pt_prone_duration=median(prone_episode_hours)) |>
  mutate(mean_pt_prone_duration=mean(prone_episode_hours)) |>
  filter(row_number()==1) |>
  ungroup() |>
  select(patient_id, encounter_block, prone_episodes:mean_pt_prone_duration)
rm(temp_times)
```

```{r Now Incorporate with Proseva Criteria Into Final Proseva-Proning Criteria for This Cohort}
#For Those Who Meet PROSEVA Criteria as OUtlined Above They are PROSEVA Eligible
#We Will Also Include Patients Who Are Proned Within 24 Hours of First Qualifying Blood Gas
proseva_prone_table <- proseva_criteria |>
  full_join(prone_episodes) |>
  #Define Those Who Meet Cohort Criteria By Being Proned Within 24 Hours of First Eligibility Regardless of 2nd PROSEVA Criteria
  mutate(eligible_by_prone=fcase(
    first_prone_time<=t_proseva_first+dhours(24) & first_prone_time>=t_proseva_first, 1,
    default = 0
  )) |>
  mutate(cohort_eligible=fifelse(
    eligible_by_proseva==1 | eligible_by_prone==1, 1, 0
  )) |>
  relocate(cohort_eligible, eligible_by_proseva, eligible_by_prone, .after = encounter_block) |>
  #Define Time of Enrollment (min(t_proseva_second, t_proning))
  mutate(t_enrollment=fcase(
    cohort_eligible==1 & is.na(first_prone_time), t_proseva_second,
    cohort_eligible==1 & t_proseva_second<first_prone_time, t_proseva_second,
    cohort_eligible==1 & t_proseva_second>=first_prone_time, first_prone_time,
    cohort_eligible==1 & eligible_by_prone==1 & eligible_by_proseva==0, first_prone_time #Those That are Proned Within 24 Hours of PROSEVA first
  )) |>
  mutate(proned=fifelse(
    !is.na(first_prone_time), 1, 0
  )) |>
  #Keep Track of Patients Who Are Proned Before Proseva Criteria Met (t_enrollment<t_proseva_first)
  mutate(cohort_eligible=fifelse(
    t_enrollment<t_proseva_first, 0, cohort_eligible
  )) |>
  #Finally, Primary Outcome is Proned within 12 Hours Of Enrollment
  mutate(prone_12hour_outcome=fcase(
    (as.duration(first_prone_time-t_enrollment)<=dhours(12)), 1,
    (as.duration(first_prone_time-t_enrollment)>dhours(12)), 0,
    !is.na(t_enrollment) & proned==0, 0
  )) |>

  #Secondary Outcomes include proning within 24h and 72h of enrollment
  mutate(prone_24hour_outcome=fcase(
    (as.duration(first_prone_time-t_enrollment)<=dhours(24)), 1,
    (as.duration(first_prone_time-t_enrollment)>dhours(24)), 0,
    !is.na(t_enrollment) & proned==0, 0
  )) |>
  mutate(prone_72hour_outcome=fcase(
    (as.duration(first_prone_time-t_enrollment)<=dhours(72)), 1,
    (as.duration(first_prone_time-t_enrollment)>dhours(72)), 0,
    !is.na(t_enrollment) & proned==0, 0
  ))   

```

```{r Now Build Final Cohort}
prone_incidence_cohort <- vent_eligible |>
  left_join(proseva_prone_table) |>
  mutate(cohort_eligible=fifelse(
    is.na(cohort_eligible), 0, cohort_eligible
  )) |>
  mutate(proned=fifelse(
    is.na(proned), 0, proned
  ))

#Before Filtering To Cohort Eligible, Keep Separate File of Proned Outside of Cohort
proned_outside_cohort <- prone_incidence_cohort |>
  filter(cohort_eligible==0 & proned==1)
cat('\n There were', length(unique(proned_outside_cohort$patient_id)), 'patients who did not meet the cohort criteria but were proned in the', site, 'cohort. \n')
#Save this File For Later
write_csv(proned_outside_cohort, paste0(project_location, "/project_tables/proned_outside_cohort", site, ".csv"))

#Finally Filter Down to Final Eligible Cohort
#Keep Track for Consort/Flow Diagrams
set.seed(32284) #For Reproducibility
n_patients <- length(unique(prone_incidence_cohort$patient_id))
prone_incidence_cohort <- prone_incidence_cohort |>
  filter(cohort_eligible==1) |>
  #Filter Out Those with t_enrollment in 2024
  filter(year(t_enrollment)<2025) |>
  #For patient_ids with more than one encounter block, select one at random
  group_by(patient_id) |>
  slice_sample(n=1) |>
  ungroup()

cat('Of', n_patients, 'with eligible ventilator episodes in the ', site, 'data', length(unique(prone_incidence_cohort$patient_id)), 'met cohort eligibility based on PROSEVA and proning criteria and are included in the final cohort. \n')

#Recalculate Final Cohort Ids
cohort_ids <- prone_incidence_cohort |>
  select(patient_id, hospitalization_id, encounter_block) |>
  mutate(in_cohort=1)

#Generate a Table of ALL HOspitalization IDs (here this Deals with the 'Linked' Encounters)
temp <- cohort_ids |> select(patient_id, encounter_block, in_cohort)
cohort_hospitalization_ids <- clif_hospitalization |>
  left_join(temp) |>
  filter(in_cohort==1) |>
  select(patient_id, hospitalization_id, encounter_block, in_cohort) |>
  collect()
rm(temp)
```

```{r Add in Covariate, Vent Data, and Patient Outcomes}
#Get Needed Variables from Hospitalization Tables
#Age, Discharge Category, Final Admission Dttm, Final Discharge Dttm
hospitalization_vars <- clif_hospitalization |>
  left_join(cohort_ids) |>
  filter(in_cohort==1) |>
  select(patient_id, encounter_block, age_at_admission, final_admission_dttm, final_discharge_dttm, final_discharge_category) |>
  collect() |>
  mutate(in_hosp_death=fifelse(
    tolower(final_discharge_category)=='expired', 1, 0
  )) |>
  mutate(death_or_hospice=fifelse(
    tolower(final_discharge_category) %in% c('expired', 'hospice'), 1, 0
  )) 

#Will Use Cohort_ids, but Also a Table of Vent Times and t_enrollment
temp <- hospitalization_vars |> select(patient_id, encounter_block, final_admission_dttm, final_discharge_dttm)
cohort_times <- prone_incidence_cohort |>
  select(patient_id, encounter_block, t_enrollment, vent_episode_start, vent_episode_end) |>
  left_join(temp) 
rm(temp)

#What Hospital is the Patient at When t_enrollment Occurs
#Was the Patient in a Procedural Area In the Week Prior to t_enrollment?
hospital_location <- clif_adt |>
  left_join(cohort_hospitalization_ids) |>
  filter(in_cohort==1) |>
  left_join(cohort_times) |>
  arrange(patient_id, encounter_block, in_dttm) |>
  collect() |>
  mutate(enrollment_icu=fifelse(
    as.POSIXct(t_enrollment, tz="UTC")>=as.POSIXct(in_dttm, tz="UTC") &
      as.POSIXct(t_enrollment, tz="UTC")<=as.POSIXct(out_dttm, tz="UTC"), 1,0
  )) |>
  #If the Patient Meets Criteria in an ED or Procedural Area Take the First Non Procedural Location After This Row
  group_by(patient_id, encounter_block) |>
  #Number the Rows
  mutate(location_count=row_number()) |>
  #Identify Location Category of the Current 'enrollment_icu'
  mutate(temp_category=fcase(
    enrollment_icu==1, location_category
  )) |>
  mutate(temp_count=fcase(
    enrollment_icu==1, location_count
  )) |>
  fill(temp_category, temp_count, .direction = 'updown') |>
  #Only Number the Locations that Come After the Number of Location Where Enrollment ICU Met
  #By Making Those At or Before T-Enrollment Allows us to Take Minimum Row Number to Get the Next
  mutate(location_count=fifelse(
    location_count<=temp_count, 99999, location_count
  )) |>
  #Make ED or Procedural Areas NA in terms of Count
  mutate(location_count=fifelse(
    location_category %in% c('ed', 'procedural'), NaN, location_count
  )) |>
  #If the Patient t_enrollment was in ed or procedural area, take the first non ed/procedural area after this
  mutate(enrollment_icu=fifelse(
    temp_category %in% c('procedural', 'ed') & 
      location_count==min(location_count, na.rm=TRUE), 1, enrollment_icu
  )) |>
  #If the Patient Meets Criteria in an Operative Area Take the First Non Procedural Location Before or After
  mutate(or_before_enrollment=fifelse(
    tolower(location_category) =='procedural' & 
      as.POSIXct(in_dttm, tz="UTC")>=as.POSIXct(t_enrollment, tz="UTC")-ddays(2) &
      as.POSIXct(in_dttm, tz="UTC")<=as.POSIXct(t_enrollment, tz="UTC"), 1, 0
  )) |>
  group_by(patient_id, encounter_block) |>
  mutate(or_before_enrollment=max(or_before_enrollment, na.rm = TRUE)) |>
  ungroup() |>
  mutate(keep=fcase(
    enrollment_icu==1, 1, 
    max(enrollment_icu, na.rm=TRUE)==0 & row_number()==1, 1
  )) |>
  filter(keep==1) |>
  select(patient_id, encounter_block, location_category, location_name, or_before_enrollment, hospital_id) |>
  rename(enrollment_location_category = location_category,
         enrollment_location_name = location_name)

demos <- clif_patient |>
  filter(patient_id %in% cohort_ids$patient_id) |>
  collect()|>
  #Need to Fix in JHU, but I have Patient Table with Individual Row for Each Hospitalization
  #Code below addresses this but should be robust to sites that only have 1 row for each patient_id
  group_by(patient_id) |>
  filter(row_number()==n()) |>
  select(patient_id, race_category, ethnicity_category, sex_category) |>
  ungroup()

#Calculate BMI
bmi <- clif_vitals |>
  filter(vital_category %in% c('weight_kg', 'height_cm')) |>
  filter(hospitalization_id %in% cohort_hospitalization_ids$hospitalization_id) |>
  #Filter Outliers
  filter((vital_category=='height_cm' & vital_value>=76.2 & vital_value<=244) |
         (vital_category=='weight_kg' & vital_value>=20 & vital_value<=1100)) |>
  collect() |>
  join(cohort_hospitalization_ids, how = 'left') |>
  join(cohort_times, how = 'left') |>
  #Pick Height and Weight Closest to Enrollment
  #First Calculate Time Difference
  mutate(time_diff=as.duration(as.POSIXct(t_enrollment)-as.POSIXct(recorded_dttm))/dhours(1)) |>
  #Define if Before or After t_entrollment
  mutate(before_enrollment=fifelse(time_diff>=0, 1, 0)) |>
  group_by(patient_id, encounter_block, before_enrollment, vital_category) |> #With this Grouping You keep Closest Before and After t_entrollment
  mutate(keep=fifelse(
    abs(time_diff)==min(abs(time_diff)), 1, 0
  )) |>
  filter(keep==1) |>
  #Now Select Height/Weight (Preferrably This is Prior to Enrollment)
  group_by(patient_id, encounter_block) |>
  mutate(study_height_cm=fcase(
    keep==1 & before_enrollment==1 & vital_category=='height_cm', vital_value
  )) |>
  mutate(study_weight_kg=fcase(
      keep==1 & before_enrollment==1 & vital_category=='weight_kg', vital_value
  )) |>
  fill(study_height_cm, study_weight_kg, .direction = 'downup') |>
  #IF missing Can Use First Value After Enrollment
  mutate(study_height_cm=fifelse(
    is.na(study_height_cm) & keep==1 & 
      before_enrollment==0 & vital_category=='height_cm', 
    vital_value, study_height_cm
  )) |>
  mutate(study_weight_kg=fifelse(
     is.na(study_weight_kg) &  keep==1 & before_enrollment==0 & vital_category=='weight_kg', 
     vital_value, study_weight_kg
  )) |>
  fill(study_height_cm, study_weight_kg, .direction = 'downup') |>
  filter(row_number()==1) |>
  ungroup() |>
  #Calculate BMI
  mutate(bmi=study_weight_kg/((study_height_cm/100)^2)) |>
  select(patient_id, encounter_block, study_height_cm, study_weight_kg, bmi)

#Lowest PF Between Time of Intubation and t_enrollment
temp_times <- cohort_times |>
  select(patient_id, encounter_block, t_enrollment)
min_pf <- vent_data |>
  filter(!is.na(pf_ratio)) |>
  join(temp_times, how = 'left') |>
  filter(as.POSIXct(recorded_dttm, tz="UTC")>=as.POSIXct(vent_episode_start, tz="UTC") &
           as.POSIXct(recorded_dttm, tz="UTC")<=as.POSIXct(t_enrollment, tz="UTC")) |>
  group_by(patient_id, encounter_block) |>
  mutate(min_pf_ratio=min(pf_ratio, na.rm = TRUE)) |>
  filter(row_number()==1) |>
  ungroup() |>
  select(patient_id, encounter_block, min_pf_ratio)
rm(temp_times)

#Calculate Norepinephrine Equivalent
pressor_data <- clif_medication_admin_continuous |>
  filter(hospitalization_id %in% cohort_hospitalization_ids$hospitalization_id) |>
  left_join(cohort_hospitalization_ids) |>
  filter(in_cohort==1) |>
  filter(med_group=='vasoactives') |>
  filter(!is.na(med_dose)) |>
  left_join(cohort_times) |>
  left_join(bmi) |> #For Weights
  arrange(patient_id, encounter_block, admin_dttm) |>
  collect() |>
  mutate(med_dose=as.character(med_dose)) |>
  mutate(med_dose = as.numeric(parse_number(med_dose))) |>
  filter(as.POSIXct(admin_dttm)>=as.POSIXct(t_enrollment)-dhours(24) & 
           as.POSIXct(admin_dttm)<=as.POSIXct(t_enrollment)) |>
  #Define if a Pressor Needs Weight Based Dosing
  mutate(med_dose_unit=tolower(med_dose_unit)) |>
  mutate(needs_wt_based=fifelse((med_dose_unit=="mcg/min" | med_dose_unit=="mg/min" | med_dose_unit=="ng/min"), 1, 0)) |>
  #Filter if Epinephrine is Given in 'mg' as this is code dosing
  filter(!(med_category=='epinephrine' & med_dose_unit=='mg')) |>
  mutate(wt_dose=fcase(
    needs_wt_based==0, med_dose,
    needs_wt_based==1, med_dose/study_weight_kg)) |>
  group_by(patient_id, encounter_block) |>
  mutate(norepi_dose=fcase(med_category=="norepinephrine" , wt_dose
  )) |>
  fill(norepi_dose, .direction ="down") |>
  mutate(norepi_on=fcase(
    norepi_dose > 0 , 1,
    (is.na(norepi_dose) | norepi_dose==0) , 0 )) |>
  mutate(norepi_dose=fifelse(is.na(norepi_dose), 0, norepi_dose)) |> #Need to Have Dose be Zero if No Dose Got Carried Forward
  mutate(epi_dose=fcase(
    med_category=="epinephrine" , wt_dose
  )) |>
  fill(epi_dose, .direction = "down") |>
  mutate(epi_on=fcase(
    epi_dose>0 , 1,
    (is.na(epi_dose) | epi_dose==0) , 0 )) |>
  mutate(epi_dose=fifelse(is.na(epi_dose), 0, epi_dose)) |>
  mutate(phenyl_dose=fcase(
    med_category=="phenylephrine" , wt_dose
  )) |>
  fill(phenyl_dose, .direction = "down") |>
  mutate(phenyl_on=fcase(
    phenyl_dose>0 , 1,
    (is.na(phenyl_dose) | phenyl_dose==0) , 0 )) |>
  mutate(phenyl_dose=fifelse(is.na(phenyl_dose), 0, phenyl_dose)) |>
  mutate(vaso_dose=fcase(
    med_category=="vasopressin" , wt_dose
  )) |>
  fill(vaso_dose, .direction = "down") |>
  mutate(vaso_on=fcase(
    vaso_dose>0 , 1,
    (is.na(vaso_dose) | vaso_dose==0) , 0 )) |>
  mutate(vaso_dose=fifelse(is.na(vaso_dose), 0, vaso_dose)) |>
  mutate(angiotensin_dose=fcase(
    med_category=="angiotensin" , wt_dose
  )) |>
  fill(angiotensin_dose, .direction = "down") |>
  mutate(angiotensin_on=fcase(
    angiotensin_dose>0 , 1,
    (is.na(angiotensin_dose) | angiotensin_dose==0) , 0 )) |>
  mutate(angiotensin_dose=fifelse(is.na(angiotensin_dose), 0, angiotensin_dose)) |>
  mutate(dopa_dose=fcase(
    med_category=="dopamine" , wt_dose
  )) |>
  fill(dopa_dose, .direction = "down") |>
  mutate(dopa_on=fcase(
    dopa_dose>0 , 1,
    (is.na(dopa_dose) | dopa_dose==0) , 0 )) |>
  mutate(dopa_dose=fifelse(is.na(dopa_dose), 0, dopa_dose)) |>
  mutate(dobut_dose=fcase(
    med_category=="dobutamine" , wt_dose
  )) |>
  fill(dobut_dose, .direction = "down") |>
  mutate(milrinone_dose=fcase(
    med_category=="milrinone" , wt_dose
  )) |>
  fill(milrinone_dose, .direction = "down") |>
  mutate(milrinone_on=fcase(
    dopa_dose>0 , 1,
    (is.na(milrinone_dose) | milrinone_dose==0) , 0 )) |>
  mutate(isoproterenol_dose=fcase(
    med_category=="isoproterenol" , wt_dose
  )) |>
  fill(isoproterenol_dose, .direction = "down") |>
  mutate(isoproterenol_on=fcase(
    isoproterenol_dose>0 , 1,
    (is.na(isoproterenol_dose) |isoproterenol_dose==0) , 0 )) |>
  ungroup() |>
  #See Kotani et al for Norepi dose equivalents for Epi, Phenyl, Vaso, Dopa, Angiotensin)
  mutate(pressor_on=(norepi_on + epi_on + phenyl_on + vaso_on + dopa_on + angiotensin_on)) |> 
  mutate(norepi_equivalent=norepi_dose + epi_dose+ vaso_dose*2.5+ angiotensin_dose*0.0025+ dopa_dose/100+ phenyl_dose*0.06) |>
  mutate(sofa_pressor=case_when(dopa_dose>15 | epi_dose>0.1 | norepi_dose>0.1 ~4, dopa_dose>5 | (epi_dose>0 & epi_dose <=0.1) | (norepi_dose>0 & norepi_dose<=0.1) ~3, (dopa_dose>0 & dopa_dose<=5) | dobut_dose>0~2 , pressor_on==0~0)) |>
  mutate(sofa_pressor=case_when(is.na(sofa_pressor)~0, is.na(sofa_pressor)==F~sofa_pressor)) |>
  collect()

#Select max sofa pressor in 24h period
sofa_pressors <- pressor_data |>
  group_by(patient_id, encounter_block) |>
  mutate(max_sofa_pressor=max(sofa_pressor, na.rm = TRUE)) |>
  filter(row_number()==1) |>
  select(patient_id, encounter_block, max_sofa_pressor) |> #, norepi_dose, epi_dose, vaso_dose, angiotensin_dose, dopa_dose, phenyl_dose) |>
  ungroup()

#Now Select Max NEE In this 24 Hour Period 
norepi_equivalent <- pressor_data |>
  filter(as.POSIXct(admin_dttm)>=as.POSIXct(t_enrollment)-dhours(24) & 
           as.POSIXct(admin_dttm)<=as.POSIXct(t_enrollment)) |>
  group_by(patient_id, encounter_block) |>
  mutate(max_norepi_equivalent=max(norepi_equivalent, na.rm = TRUE)) |>
  filter(row_number()==1) |>
  mutate(nee_pressor_dose=case_when(max_norepi_equivalent==0~0, max_norepi_equivalent>0 & max_norepi_equivalent<=0.1~1, max_norepi_equivalent>.1~2)) |>
  select(patient_id, encounter_block, nee_pressor_dose) |> #, norepi_dose, epi_dose, vaso_dose, angiotensin_dose, dopa_dose, phenyl_dose) |>
  ungroup()

# Calculate lowest GCS for sofa in 24h prior to enrollment
sofa_gcs <- clif_patient_assessments |>
  filter(assessment_category == "gcs_total") |> 
  filter(hospitalization_id %in% cohort_hospitalization_ids$hospitalization_id) |> 
  #Filter Outliers  
  filter(numerical_value<=15 & numerical_value>=3) |>
  collect() |>
  join(cohort_hospitalization_ids, how = 'left') |>
  join(cohort_times, how = 'left') |>
  #Pick in 24h prior to enrollment
  filter(as.POSIXct(recorded_dttm)>=as.POSIXct(t_enrollment)-dhours(24) & 
           as.POSIXct(recorded_dttm)<=as.POSIXct(t_enrollment)) |>
  mutate(sofa_gcs=case_when(numerical_value==15~0,  numerical_value==13 | numerical_value==14~1, numerical_value>=10 & numerical_value<=12~2, numerical_value>=6 & numerical_value<=9~3, numerical_value<6~4)) |> 
  group_by(patient_id, encounter_block) |>
  mutate(max_sofa_gcs=max(sofa_gcs, na.rm = TRUE)) |>
  filter(row_number()==1) |>
  select(patient_id, encounter_block, max_sofa_gcs) |> 
  ungroup()

# Calculate lowest RASS for sofa in 24h prior to enrollment
sofa_rass <- clif_patient_assessments |> 
  filter(assessment_category == "RASS") |> 
  filter(hospitalization_id %in% cohort_hospitalization_ids$hospitalization_id) |> 
  #Filter Outliers  
  filter(numerical_value<=4 & numerical_value>-6) |>
  collect() |>
  join(cohort_hospitalization_ids, how = 'left') |>
  join(cohort_times, how = 'left') |>
  #Pick in 24h prior to enrollment
  filter(as.POSIXct(recorded_dttm)>=as.POSIXct(t_enrollment)-dhours(24) & 
           as.POSIXct(recorded_dttm)<=as.POSIXct(t_enrollment)) |> 
  mutate(sofa_rass=case_when(numerical_value>-1~0,  numerical_value==-1~1, numerical_value==-2~2, numerical_value==-3~3, numerical_value==-4 | numerical_value==-5~4)) |> 
  group_by(patient_id, encounter_block) |>
  mutate(max_sofa_rass=max(sofa_rass, na.rm = TRUE)) |>
  filter(row_number()==1) |>
  select(patient_id, encounter_block, max_sofa_rass) |> 
  ungroup()

#Calculate Lowest MAP 24h prior to enrollment for SOFA
sofa_map <- clif_vitals |>
  filter(vital_category %in% c('map')) |>
  filter(hospitalization_id %in% cohort_hospitalization_ids$hospitalization_id) |>
  #Filter Outliers MAP>250
  filter(vital_value<=250) |>
  collect() |>
  join(cohort_hospitalization_ids, how = 'left') |>
  join(cohort_times, how = 'left') |>
  #Pick Lowest MAP in 24h prior to enrollment
  filter(as.POSIXct(recorded_dttm)>=as.POSIXct(t_enrollment)-dhours(24) & 
           as.POSIXct(recorded_dttm)<=as.POSIXct(t_enrollment)) |>
  mutate(sofa_map=case_when(vital_value<70~1, vital_value>=70~0)) |>
  group_by(patient_id, encounter_block) |>
  mutate(max_sofa_map=max(sofa_map, na.rm = TRUE)) |>
  filter(row_number()==1) |>
  select(patient_id, encounter_block, max_sofa_map) |> #, norepi_dose, epi_dose, vaso_dose, angiotensin_dose, dopa_dose, phenyl_dose) |>
  ungroup()

#Calculate highest bilirubin in 24h prior to enrollment for sofa
sofa_bili <- clif_labs |>
  filter(lab_category %in% c('bilirubin_total')) |>
  filter(hospitalization_id %in% cohort_hospitalization_ids$hospitalization_id) |>
  #Filter Outliers  
  filter(lab_value_numeric<=80) |>
  collect() |>
  join(cohort_hospitalization_ids, how = 'left') |>
  join(cohort_times, how = 'left') |>
  #Pick in 24h prior to enrollment
  filter(as.POSIXct(lab_collect_dttm)>=as.POSIXct(t_enrollment)-dhours(24) & 
           as.POSIXct(lab_collect_dttm)<=as.POSIXct(t_enrollment)) |>
  mutate(sofa_bili=case_when(lab_value_numeric<1.2~0,  lab_value_numeric>=1.2 & lab_value_numeric<2~1, lab_value_numeric>=2 & lab_value_numeric<6~2, lab_value_numeric>=6 & lab_value_numeric<12~3, lab_value_numeric>=12~4)) |> 
  group_by(patient_id, encounter_block) |>
  mutate(max_sofa_bili=max(sofa_bili, na.rm = TRUE)) |>
  filter(row_number()==1) |>
  select(patient_id, encounter_block, max_sofa_bili) |> 
  ungroup()

#Calculate lowest platelets in 24h prior to enrollment for sofa
sofa_plt <- clif_labs |>
  filter(lab_category %in% c('platelet_count')) |>
  filter(hospitalization_id %in% cohort_hospitalization_ids$hospitalization_id) |>
  #Filter Outliers 
  filter(lab_value_numeric<=2000) |>
  collect() |>
  join(cohort_hospitalization_ids, how = 'left') |>
  join(cohort_times, how = 'left') |>
  #Pick Lowest in 24h prior to enrollment
  filter(as.POSIXct(lab_collect_dttm)>=as.POSIXct(t_enrollment)-dhours(24) & 
           as.POSIXct(lab_collect_dttm)<=as.POSIXct(t_enrollment)) |> 
  mutate(sofa_plt=case_when(lab_value_numeric<20~4,  lab_value_numeric>=20 & lab_value_numeric<50~3, lab_value_numeric>=50 & lab_value_numeric<100~2, lab_value_numeric>=100 & lab_value_numeric<150~1, lab_value_numeric>=150~0)) |> 
  group_by(patient_id, encounter_block) |>
  mutate(max_sofa_plt=max(sofa_plt, na.rm = TRUE)) |>
  filter(row_number()==1) |>
  select(patient_id, encounter_block, max_sofa_plt) |> 
  ungroup()

#Calculate highest cr in 24h prior to enrollment for sofa
sofa_cr <- clif_labs |>
  filter(lab_category %in% c('creatinine')) |>
  filter(hospitalization_id %in% cohort_hospitalization_ids$hospitalization_id) |>
  #Filter Outliers 
  filter(lab_value_numeric<=20) |>
  collect() |>
  join(cohort_hospitalization_ids, how = 'left') |>
  join(cohort_times, how = 'left') |>
  #Pick Lowest in 24h prior to enrollment
  filter(as.POSIXct(lab_collect_dttm)>=as.POSIXct(t_enrollment)-dhours(24) & 
           as.POSIXct(lab_collect_dttm)<=as.POSIXct(t_enrollment)) |> 
  mutate(sofa_cr=case_when(lab_value_numeric<1.2~0,  lab_value_numeric>=1.2 & lab_value_numeric<2~1, lab_value_numeric>=2 & lab_value_numeric<3.5~2, lab_value_numeric>=3.5 & lab_value_numeric<5~3, lab_value_numeric>=5~4)) |> 
  group_by(patient_id, encounter_block) |>
  mutate(max_sofa_cr=max(sofa_cr, na.rm = TRUE)) |>
  filter(row_number()==1) |>
  select(patient_id, encounter_block, max_sofa_cr) |> 
  ungroup()

#SARS COV2 Positivity - Do this At Patient Level Anytime in the 4 Weeks Prior to t_enrollment
sars_cov2 <- clif_microbiology_nonculture |>
  filter(patient_id %in% cohort_times$patient_id) |>
  select(-hospitalization_id) |> #Want to Merge on Patient Level
  filter(micro_category %in% c('sars_cov2_pcr', 'sars_cov2_antigen', 'sars_cov2_na')) |>
  left_join(cohort_hospitalization_ids) |> #Merges in Encounter Block
  left_join(cohort_times) |>
  collect() |>
  filter(lab_collect_dttm<=t_enrollment & lab_collect_dttm>=t_enrollment-dweeks(4)) |>
  group_by(patient_id, encounter_block) |>
  mutate(sars_cov2_positive=fifelse(
    sum(tolower(result_category)=='detected', na.rm=TRUE)>=1, 1, 0)) |>
  filter(row_number()==1) |>
  select(patient_id, encounter_block, sars_cov2_positive)

prone_analytic_data <- hospitalization_vars |>
  left_join(demos) |>
  left_join(hospital_location) |>
  left_join(bmi) |>
  left_join(prone_incidence_cohort) |>
  left_join(min_pf) |>
  left_join(norepi_equivalent) |>
  left_join(sofa_pressors) |>
  left_join(sofa_map) |>
  left_join(sofa_rass) |>
  left_join(sofa_gcs) |>
  left_join(sofa_bili) |>
  left_join(sofa_cr) |>
  left_join(sofa_plt) |>
  left_join(sars_cov2) |>

  #IF norepi equivalent is missing it means patient had no vasoactives recorded
  mutate(nee_pressor_dose=fifelse(is.na(nee_pressor_dose), 0, nee_pressor_dose)) |>
  mutate(max_sofa_pressor=fifelse(is.na(max_sofa_pressor), 0, max_sofa_pressor)) |>
  mutate(max_sofa_bili=fifelse(is.na(max_sofa_bili), 0, max_sofa_bili)) |>
  mutate(max_sofa_hemodynamics=case_when(max_sofa_pressor>1~max_sofa_pressor, max_sofa_pressor<2~max_sofa_map)) |> 
  mutate(max_sofa_ams=case_when(max_sofa_gcs>=max_sofa_rass | is.na(max_sofa_rass)~max_sofa_gcs, max_sofa_gcs<max_sofa_rass | is.na(max_sofa_gcs)~max_sofa_rass)) |> 
  mutate(sofa_score=max_sofa_plt + max_sofa_ams + max_sofa_bili + max_sofa_hemodynamics + max_sofa_cr) |>
  select(-hospitalization_id) |>
  #Race and ethnicity mappings: 1=white, non hispanic, 2=hispanic, regardless of race, 3=black non-hispanic, 4=asian, non-hispanic, 5=other, 6=Unknown
  mutate(race_ethnicity=fcase(
    tolower(race_category)=="white" & 
      tolower(ethnicity_category) %in% c('non-hispanic'), 'White, non-Hispanic',
    tolower(ethnicity_category)=='hispanic', 'Hispanic',
    tolower(race_category)=='black or african american' & 
      tolower(ethnicity_category) %in% c('non-hispanic'), 'Black, non-Hispanic',
    tolower(race_category)=='asian', 'Asian',
    tolower(race_category) %!in% c('white', 'black or african american', 'asian', 'unknown'), 'other',
    tolower(race_category) == "unknown" | is.na(race_category) |
    tolower(ethnicity_category) == "unknown" | is.na(ethnicity_category), "unknown")) |>
  select(-mode_category, -device_category) |>
  #Calculate Time from Admission to Enrollment
  mutate(days_admit_to_enroll=as.duration(t_enrollment-final_admission_dttm)/ddays(1)) |>
  #Calcualte Time from Enrollment to Proning
  mutate(time_to_prone_hrs=fifelse(
    proned==1, as.duration(first_prone_time-t_enrollment)/dhours(1), NaN)) |>
  distinct()
rm(bmi, demos, hospitalization_vars, hospital_location, min_pf, norepi_equivalent)

or_table<-table(prone_analytic_data$prone_12hour_outcome, prone_analytic_data$or_before_enrollment, useNA = "always")
write.csv(or_table, file=paste0(project_location, '/project_output/', site, '_OR_proning.csv'))

#exclude patients who go to the OR prior to study enrollment from cohort
prone_analytic_data<- prone_analytic_data %>% filter(or_before_enrollment!=1)

write_parquet(prone_analytic_data, paste0(project_location, '/project_tables/prone_analytic_data.parquet'))
```


```{r}
## Export the list of `hospitalization_id` for the identified patients
non_or<- prone_analytic_data |>
  select(patient_id, encounter_block) |>
  mutate(keep=1)

cohort_hospitalization_ids <- cohort_hospitalization_ids |>
  left_join(non_or) |>
  filter(keep==1) |>
  select(-keep)
  
save(cohort_hospitalization_ids, file = paste0(project_location, "/project_tables/cohort_hospitalization_ids.RData"))
```

## Filter the CLIF tables for the identified hospitalizations
```{r}
filter_clif_table <- function(table, filter_col, cohort_ids, select_cols = NULL) {
  filtered_table <- table %>%
    filter(!!sym(filter_col) %in% cohort_ids) |>
    collect()
  
  return(filtered_table)
}

#remove the patient table from the list of tables to filter
table_flags["patient"] <- FALSE

# Filter the required tables for the identified hospitalizations
for (table_name in names(table_flags)[table_flags]) {
  # Dynamically construct the full table name (e.g., "clif_labs", "clif_vitals")
  full_table_name <- paste0("clif_", table_name)
  
  # Assign the filtered result to a new variable with "_cohort" suffix
  assign(
    paste0(full_table_name, "_cohort"), 
    filter_clif_table(get(full_table_name), "hospitalization_id", cohort_hospitalization_ids$hospitalization_id)
  )
}

# Filter the patient table for the identified patients
clif_patient_cohort <- clif_patient |>
  filter(patient_id %in% cohort_hospitalization_ids$patient_id) |>
  collect()
```

## Save all filtered tables to the `study_cohort` folder
```{r}
save(list = ls(pattern = "clif_.*_cohort"), 
     file = paste0(project_location, "/project_tables/clif_cohort_tables.RData"))
```


```{r End Time}
toc()
```

